#!/usr/bin/env python

import sys
import json
import time
import re

file_fmt = '''/**
 * @file {filename}
 * @version 1.0
 *
 * @section License
 * Copyright (C) 2014-2015, Erik Moqvist
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * This file is part of the Simba project.
 */

/**
 * This file was generated by fs.py {major}.{minor} {date}.
 */

#include "simba.h"

{fs}

{qlog}
'''

fs_fmt = '''{command_externs}

{counter_externs}

{parameter_externs}

{strings}

const FAR struct fs_node_t fs_nodes[] = {{
{fs_nodes}
}};

const FAR int fs_counters[] = {{
{counters_list}
  -1
}};

const FAR int fs_parameters[] = {{
{parameters_list}
  -1
}};
'''

qlog_fmt = '''{qlog_ids}

{qlog_strings}

const char FAR *qlog_id_to_string[] = {{
{qlog_strings_array}
}};
'''

command_extern_fmt = 'extern int {callback}(int argc, const char *argv[], void *out_p, void *in_p);'
counter_extern_fmt = 'extern long long FS_COUNTER({name});'
parameter_extern_fmt = 'extern {type} FS_PARAMETER({name});'

strings_fmt = 'static FAR const char {name}[] = "{value}";'

node_fmt = '''    /* index: {index} */
    {{
        .next = {next},
        .name_p = {name},
        .children = {{
            .begin = {begin},
            .end = {end},
            .len = {len}
        }},
        .parent = {parent},
        .callback = {callback}
    }},'''

list_entry_fmt = '{index},'

major = 1
minor = 0

nodeindex = 0

def generate_nodes(parent, nodes, name, children, next, path):
    global nodeindex
    index = nodeindex
    nodeindex += 1
    if type(children) == type(''):
        begin = 0
        end = 0
        length = 0
        callback = children
    else:
        end = nodeindex
        length = len(children)
        callback = "NULL"
        i = 0
        for n, c in children.items():
            i = generate_nodes(index, nodes, n, c, i, path + name + "/")
        begin = i
    nodes.append((index,
                  node_fmt.format(index=index,
                                  next=next,
                                  name=name,
                                  begin=begin,
                                  end=end,
                                  len=length,
                                  parent=parent,
                                  callback=callback),
                  name,
                  (path + name).replace('/__slash', '')))
    return index

def generate_fs(infiles):
    """Generate file system commands, counters and parameters.
    """
    re_command = re.compile('^\w*\.\.fs_command\.\. '
                            '"(?P<path>[^"]+)" '
                            '"(?P<callback>[^"]+)";$', re.MULTILINE)
    re_counter = re.compile('^\w*\.\.fs_counter\.\. '
                            '"(?P<path>[^"]+)" '
                            '"(?P<name>[^"]+)";$', re.MULTILINE)
    re_parameter = re.compile('^\w*\.\.fs_parameter\.\. '
                              '"(?P<path>[^"]+)" '
                              '"(?P<name>[^"]+)" '
                              '"(?P<type>[^"]+)";$',
                              re.MULTILINE)

    # create lists of files and counters
    commands = []
    counters = []
    parameters = []
    for inf in infiles:
        file_content = open(inf).read()
        for mo in re_command.finditer(file_content):
            commands.append([mo.group('path'), mo.group('callback')])
        for mo in re_counter.finditer(file_content):
            counters.append([mo.group('path'), mo.group('name')])
            commands.append([mo.group('path'), 'fs_counter_cmd_' + mo.group('name')])
        for mo in re_parameter.finditer(file_content):
            parameters.append([mo.group('path'),
                               mo.group('name'),
                               mo.group('type')])
            commands.append([mo.group('path'), 'fs_parameter_cmd_' + mo.group('name')])

    fs = {}
    command_externs = []

    # create a dictionary of given file system
    for command in commands:
        parts = command[0].split('/')[1:]
        name = parts[-1]
        parts = parts[0:-1]
        callback = command[1]
        fspath = fs
        for part in parts:
            if not part in fspath:
                fspath[part] = {}
            fspath = fspath[part]
        fspath[name] = callback
        command_externs.append(command_extern_fmt.format(callback=callback))

    # generate counters
    counter_externs = []
    for counter in counters:
        counter_externs.append(counter_extern_fmt.format(name=counter[1]))

    #parameters
    parameter_externs = []
    for parameter in parameters:
        parameter_externs.append(parameter_extern_fmt.format(name=parameter[1],
                                                             type=parameter[2]))

    # generate c source file
    fs_nodes = []
    generate_nodes(-1, fs_nodes, '__slash', fs, 0, "/")
    fs_nodes.sort(key=lambda n: n[0])

    # strings
    strings = [strings_fmt.format(name=name,
                                  value=name)
               for _, _, name, _ in fs_nodes
               if name != '__slash']
    strings.append(strings_fmt.format(name='__slash', value="/"))

    # remote duplicates
    strings = list(set(strings))

    # counters list
    counters_list = []
    for counter in counters:
        for node in fs_nodes:
            if counter[0] == node[3]:
                counters_list.append(list_entry_fmt.format(index=node[0]))
                break

    # parameters list
    parameters_list = []
    for parameter in parameters:
        for node in fs_nodes:
            if parameter[0] == node[3]:
                parameters_list.append(list_entry_fmt.format(index=node[0]))
                break

    return fs_fmt.format(command_externs='\n'.join(command_externs),
                         counter_externs='\n'.join(counter_externs),
                         parameter_externs='\n'.join(parameter_externs),
                         strings='\n'.join(strings),
                         fs_nodes='\n'.join(n[1] for n in fs_nodes),
                         counters_list='\n'.join(counters_list),
                         parameters_list='\n'.join(parameters_list))


def generate_qlog(infiles):
    """Generate qlog identities and strings.
    """
    re_qlog = re.compile('^\w*\.\.qlog\.\. '
                         '"(?P<level>[^"]+)" '
                         '"(?P<name>[^"]+)" '
                         '"(?P<fmt>[^"]+)";$',
                         re.MULTILINE)


    # create lists of files and counters
    qlog_defines = []
    for inf in infiles:
        file_content = open(inf).read()
        for mo in re_qlog.finditer(file_content):
            qlog_defines.append([mo.group('level'), mo.group('name'), mo.group('fmt')])

    identity = 0
    qlog_ids = []
    qlog_strings = []
    qlog_strings_array = []
    for qlog_define in qlog_defines:
        level = qlog_define[0]
        name = qlog_define[1]
        fmt = qlog_define[2]

        qlog_ids.append("qlog_id_t qlog_id_{name} = ((STD_LOG_{level} << 16) | {identity});"
                        .format(level=level, name=name, identity=identity))
        qlog_strings.append('static FAR const char qlog_id_{name}_fmt[] = "{fmt}\\r\\n";'
                            .format(name=name, fmt=fmt))
        qlog_strings_array.append("qlog_id_{name}_fmt,".format(name=name))

        identity += 1

    return qlog_fmt.format(qlog_ids='\n'.join(qlog_ids),
                           qlog_strings='\n'.join(qlog_strings),
                           qlog_strings_array='\n'.join(qlog_strings_array))


if __name__ == '__main__':
    outfile = sys.argv[1]
    infiles = sys.argv[2:]

    fs_formatted_data = generate_fs(infiles)
    qlog_formatted_data = generate_qlog(infiles)

    fout = open(outfile, 'w').write(
        file_fmt.format(filename=outfile,
                        major=major,
                        minor=minor,
                        date=time.strftime("%Y-%m-%d %H:%M %Z"),
                        fs=fs_formatted_data,
                        qlog=qlog_formatted_data))
