#!/usr/bin/env python

import sys
import time
import struct
import re

from ConfigParser import ConfigParser
from collections import OrderedDict


MAJOR=1
MINOR=0

SETTINGS_H_FILENAME = "settings.h"
SETTINGS_C_FILENAME = "settings.c"
SETTINGS_BIN_FILENAME = "settings.bin"

HEADER_FMT = """/**
 * @file {filename}
 * @version 1.0
 *
 * @section License
 * Copyright (C) 2014-2015, Erik Moqvist
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * This file is part of the Simba project.
 */

/**
 * This file was generated by setting.py {major}.{minor} {date}.
 */

#ifndef __SETTINGS_H__
#define __SETTINGS_H__

{addresses}

{sizes}

{types}

{values}

#endif
"""

SOURCE_FMT = """/**
 * @file {filename}
 * @version 1.0
 *
 * @section License
 * Copyright (C) 2014-2015, Erik Moqvist
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * This file is part of the Simba project.
 */

/**
 * This file was generated by setting.py {major}.{minor} {date}.
 */

#include "simba.h"

char setting_area[4096] __attribute__ ((section (".setting"))) = {{
{content}
}};
"""

re_integer = re.compile(r"(?P<sign>[u]?)int(?P<bits>\d+)_t")


def parse_setting_file(filename):
    setting_parser = ConfigParser()
    setting_parser.read(filename)

    addresses = []
    sizes = []
    values = []
    types = []

    for item in setting_parser.items("addresses"):
        addresses.append((item[0], int(item[1], 0)))

    for item in setting_parser.items("sizes"):
        sizes.append((item[0], int(item[1], 0)))

    for item in setting_parser.items("types"):
        types.append((item[0], item[1]))

    for item in setting_parser.items("values"):
        values.append((item[0], item[1]))

    addresses.sort(key=lambda item: item[1])

    return addresses, sizes, types, values


def create_setting_dict(addresses, sizes, types, values):
    setting = OrderedDict()

    for name, address in addresses:
        setting[name] = {"address": address}

    for name, size in sizes:
        if name not in setting:
            sys.stderr.write("{}: no address for setting\n".format(name))
            sys.exit(1)
        setting[name]["size"] = size

    for name, type in types:
        if name not in setting:
            sys.stderr.write("{}: no address for setting\n".format(name))
            sys.exit(1)
        setting[name]["type"] = type

    for name, value in values:
        if name not in setting:
            sys.stderr.write("{}: no address for setting\n".format(name))
            sys.exit(1)
        setting[name]["value"] = value

    return setting


def create_binary_content(setting, endianess):
    endianess_prefix = ">" if endianess == "big" else "<"
    # create the setting file content
    content = ""
    for name, item in setting.items():
        # add padding between previous setting and this one
        content += "\xff" * (item["address"] - len(content))
        # add the value
        if item["type"] == "string":
            if item["size"] <= len(item["value"]):
                sys.stderr.write("{}: value does not fit in size {}\n".format(item["value"],
                                                                              item["size"]))
                sys.exit(1)
            content += item["value"]
            # null termination
            content += "\x00"
        elif re_integer.match(item["type"]):
            bits_to_fmt = {
                8: "b",
                16: "h",
                32: "i",
                64: "q"
            }
            mo = re_integer.match(item["type"])
            sign = mo.group("sign")
            bits = int(mo.group("bits"))
            if bits not in [8, 16, 32, 64]:
                sys.stderr.write("{}: bad type\n".format(item["type"]))
                sys.exit(1)
            if bits / 8 != item["size"]:
                sys.stderr.write("{}: bad length of {}\n".format(item["size"],
                                                                 item["type"]))
                sys.exit(1)
            fmt = bits_to_fmt[bits]
            if sign == "u":
                fmt.upper()
            content += struct.pack(endianess_prefix + fmt, int(item["value"], 0))
        else:
            sys.stderr.write("{}: bad type\n".format(item["type"]))
            sys.exit(1)

    return content


def create_header_file(setting):

    addresses = []
    sizes = []
    types = []
    values = []

    for name, item in setting.items():
        addresses.append("#define SETTINGS_{name}_ADDR {value}"
                         .format(name=name.upper(), value=item["address"]))
        sizes.append("#define SETTINGS_{name}_SIZE {value}"
                     .format(name=name.upper(), value=item["size"]))
        types.append("#define SETTINGS_{name}_TYPE {value}"
                     .format(name=name.upper(), value=item["type"]))
        values.append("#define SETTINGS_{name}_VALUE {value}"
                      .format(name=name.upper(), value=item["value"]))

    now = time.strftime("%Y-%m-%d %H:%M %Z")

    # write to setting header file
    with open(SETTINGS_H_FILENAME, "w") as fout:
        fout.write(HEADER_FMT.format(filename=SETTINGS_H_FILENAME,
                                     date=now,
                                     major=MAJOR,
                                     minor=MINOR,
                                     addresses="\n".join(addresses),
                                     sizes="\n".join(sizes),
                                     types="\n".join(types),
                                     values="\n".join(values)))


def create_binary_file(content):
    # write the content to the setting file
    with open(SETTINGS_BIN_FILENAME, "wb") as fout:
        fout.write(content)


def create_source_file(content):
    now = time.strftime("%Y-%m-%d %H:%M %Z")

    content_bytes = ['{:#04x}'.format(ord(byte)) for byte in content]

    # write to setting source file
    with open(SETTINGS_C_FILENAME, "w") as fout:
        fout.write(SOURCE_FMT.format(filename=SETTINGS_C_FILENAME,
                                     date=now,
                                     major=MAJOR,
                                     minor=MINOR,
                                     content=', '.join(content_bytes)))
    

if __name__ == "__main__":
    endianess = sys.argv[2]
    items = parse_setting_file(sys.argv[1])
    setting = create_setting_dict(*items)

    create_header_file(setting)
    content = create_binary_content(setting, endianess)
    create_binary_file(content)
    create_source_file(content)
