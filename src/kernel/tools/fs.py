#!/usr/bin/env python

import sys
import json
import time
import re

file_fmt = '''/**
 * @file {filename}
 * @version 1.0
 *
 * @section License
 * Copyright (C) 2014-2015, Erik Moqvist
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * This file is part of the Simba project.
 */

/**
 * This file was generated by fs.py {major}.{minor} {date}.
 */

#include "simba.h"

{extern}

{parameter_extern}

{strings}

const FAR struct fs_node_t fs_nodes[] = {{
{fs_nodes}
}};

{counters}
'''

extern_fmt = 'extern int {callback}(int argc, const char *argv[], void *out_p, void *in_p);'

strings_fmt = 'static FAR const char {name}[] = "{value}";'

node_fmt = '''    /* index: {index} */
    {{
        .next = {next},
        .name_p = {name},
        .children = {{
            .begin = {begin},
            .end = {end},
            .len = {len}
        }},
        .callback = {callback}
    }},'''

counter_fmt = '''struct fs_counter_t fs_counter_{name} = {{
    .next_p = {next},
    .value = 0,
    .name_p = {name}
}};'''

parameter_extern_fmt = '''extern {type} FS_PARAMETER({name});'''

major = 1
minor = 0

nodeindex = 0

def node_generate_c(nodes, name, children, next):
    global nodeindex
    index = nodeindex
    nodeindex += 1
    if type(children) == type(''):
        begin = 0
        end = 0
        length = 0
        callback = children
    else:
        end = nodeindex
        length = len(children)
        callback = "NULL"
        i = 0
        for n, c in children.items():
            i = node_generate_c(nodes, n, c, i)
        begin = i
    nodes.append((index, node_fmt.format(index=index,
                                         next=next,
                                         name=name,
                                         begin=begin,
                                         end=end,
                                         len=length,
                                         callback=callback), name))
    return index

if __name__ == '__main__':
    outfile = sys.argv[1]
    infiles = sys.argv[2:]

    re_command = re.compile('^\w*\.\.fs_command\.\. '
                            '"(?P<command>[^"]+)" '
                            '"(?P<callback>[^"]+)";$', re.MULTILINE)
    re_counter = re.compile('^\w*\.\.fs_counter\.\. '
                            '"(?P<name>[^"]+)";$', re.MULTILINE)
    re_parameter = re.compile('^\w*\.\.fs_parameter\.\. '
                              '"(?P<command>[^"]+)" '
                              '"(?P<name>[^"]+)" '
                              '"(?P<type>[^"]+)";$',
                              re.MULTILINE)

    # create lists of files and counters
    commands = []
    counters = []
    parameters = []
    for inf in infiles:
        file_content = open(inf).read()
        for mo in re_command.finditer(file_content):
            commands.append([mo.group('command'), mo.group('callback')])
        for mo in re_counter.finditer(file_content):
            counters.append(mo.group('name'))
        for mo in re_parameter.finditer(file_content):
            parameters.append([mo.group('command'),
                               mo.group('name'),
                               mo.group('type')])
            commands.append([mo.group('command'), 'fs_parameter_cmd_' + mo.group('name')])

    fs = {}
    extern = []

    # create a dictionary of given file system
    for command in commands:
        parts = command[0].split('/')[1:]
        name = parts[-1]
        parts = parts[0:-1]
        callback = command[1]
        fspath = fs
        for part in parts:
            if not part in fspath:
                fspath[part] = {}
            fspath = fspath[part]
        fspath[name] = callback
        extern.append(extern_fmt.format(callback=callback))

    # generate counters
    fs_counters = []
    counters.sort()
    counters.insert(0, "__base")
    for i, name in enumerate(counters[0:-1]):
        fs_counters.append(counter_fmt.format(next='&fs_counter_' + counters[i+1],
                                              name=name))
    fs_counters.append(counter_fmt.format(next='NULL',
                                          name=counters[-1]))
    fs_counters.reverse()

    #parameters
    fs_parameter_extern = []
    for parameter in parameters:
        fs_parameter_extern.append(parameter_extern_fmt.format(name=parameter[1],
                                                               type=parameter[2]))

    # generate c source file
    fs_nodes = []
    node_generate_c(fs_nodes, '__slash', fs, 0)
    fs_nodes.sort(key=lambda n: n[0])

    # strings

    # commands
    strings = [strings_fmt.format(name=name,
                                  value=name)
               for _, _, name in fs_nodes
               if name != '__slash']
    strings.append(strings_fmt.format(name='__slash', value="/"))

    # counters
    strings.extend([strings_fmt.format(name=name,
                                       value=name)
                    for name in counters
                    if name != '__base'])
    strings.append(strings_fmt.format(name='__base', value=""))

    # remote duplicates
    strings = list(set(strings))

    fout = open(outfile, 'w').write(
        file_fmt.format(filename=outfile,
                        major=major,
                        minor=minor,
                        date=time.strftime("%Y-%m-%d %H:%M %Z"),
                        extern='\n'.join(extern),
                        parameter_extern='\n'.join(fs_parameter_extern),
                        strings='\n'.join(strings),
                        fs_nodes='\n'.join(n[1] for n in fs_nodes),
                        counters='\n'.join(fs_counters)))
